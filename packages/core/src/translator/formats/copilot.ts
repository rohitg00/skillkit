import type { AgentType } from '../../types.js';
import type {
  FormatTranslator,
  CanonicalSkill,
  TranslationResult,
  TranslationOptions,
  FormatCategory,
} from '../types.js';

/**
 * Parse metadata from markdown comments (same as Windsurf)
 */
function parseMetadataComments(content: string): { metadata: Record<string, string>; body: string } {
  const metadata: Record<string, string> = {};
  const lines = content.split('\n');
  const bodyLines: string[] = [];
  let inMetadata = true;

  for (const line of lines) {
    if (inMetadata) {
      const match = line.match(/^<!--\s*(\w+):\s*(.+?)\s*-->$/);
      if (match) {
        metadata[match[1].toLowerCase()] = match[2];
        continue;
      }
      if (line.trim() && !line.startsWith('<!--')) {
        inMetadata = false;
      }
    }
    bodyLines.push(line);
  }

  return {
    metadata,
    body: bodyLines.join('\n').trim(),
  };
}

/**
 * GitHub Copilot Instructions Format Translator
 *
 * GitHub Copilot uses a markdown file at `.github/copilot-instructions.md`
 * for custom instructions. It's plain markdown with optional metadata comments.
 *
 * Format:
 * ```
 * <!-- This file provides custom instructions for GitHub Copilot -->
 *
 * # Coding Guidelines
 *
 * ## React Components
 * - Use functional components with hooks
 * - Prefer TypeScript
 * ```
 */
export class CopilotTranslator implements FormatTranslator {
  readonly format: FormatCategory = 'markdown-rules';
  readonly agents: AgentType[] = ['github-copilot'];

  /**
   * Parse Copilot instructions into canonical format
   */
  parse(content: string, filename?: string): CanonicalSkill | null {
    const { metadata, body } = parseMetadataComments(content);

    // Try to extract name from metadata or first heading
    let name = metadata.name;
    if (!name) {
      const headingMatch = body.match(/^#\s+(.+)$/m);
      if (headingMatch) {
        name = headingMatch[1]
          .toLowerCase()
          .replace(/\s+/g, '-')
          .replace(/[^a-z0-9-]/g, '');
      } else if (filename) {
        name = filename
          .replace(/\.(md)$/i, '')
          .replace(/copilot-instructions/i, 'copilot-rules')
          .toLowerCase()
          .replace(/\s+/g, '-')
          .replace(/[^a-z0-9-]/g, '');
      } else {
        name = 'copilot-instructions';
      }
    }

    // Extract description
    let description = metadata.description;
    if (!description) {
      const paragraphMatch = body.match(/^(?!#)[^\n]+/m);
      if (paragraphMatch) {
        description = paragraphMatch[0].substring(0, 200);
        if (description.length === 200) description += '...';
      } else {
        description = 'GitHub Copilot instructions';
      }
    }

    return {
      name,
      description,
      content: body,
      sourceFormat: 'markdown-rules',
      sourceAgent: 'github-copilot',
      version: metadata.version,
      author: metadata.author,
      tags: metadata.tags?.split(',').map((t) => t.trim()),
    };
  }

  /**
   * Check if content is GitHub Copilot format
   */
  detect(content: string, filename?: string): boolean {
    // Check filename
    if (filename) {
      if (/copilot-instructions\.md$/i.test(filename)) return true;
      if (/copilot.*instructions/i.test(filename)) return true;
    }

    // Check for Copilot-specific comments
    if (content.toLowerCase().includes('github copilot')) {
      return true;
    }

    return false;
  }

  /**
   * Generate GitHub Copilot instructions content
   */
  generate(
    skill: CanonicalSkill,
    targetAgent: AgentType,
    options: TranslationOptions = {}
  ): TranslationResult {
    const warnings: string[] = [];
    const incompatible: string[] = [];
    const lines: string[] = [];

    // Add header comment
    lines.push('<!-- This file provides custom instructions for GitHub Copilot -->');
    lines.push('<!-- Generated by SkillKit - https://github.com/rohitg00/skillkit -->');
    lines.push('');

    // Add metadata as comments if requested
    if (options.addMetadata) {
      lines.push(`<!-- name: ${skill.name} -->`);
      lines.push(`<!-- description: ${skill.description} -->`);
      if (skill.version) lines.push(`<!-- version: ${skill.version} -->`);
      if (skill.author) lines.push(`<!-- author: ${skill.author} -->`);
      lines.push(`<!-- translatedFrom: ${skill.sourceFormat} -->`);
      lines.push(`<!-- translatedAt: ${new Date().toISOString()} -->`);
      lines.push('');
    }

    // Note incompatible features
    if (skill.globs?.length) {
      incompatible.push('globs: GitHub Copilot does not support file pattern matching');
    }
    if (skill.alwaysApply !== undefined) {
      incompatible.push('alwaysApply: GitHub Copilot does not support conditional application');
    }
    if (skill.allowedTools) {
      incompatible.push('allowed-tools: GitHub Copilot does not support tool restrictions');
    }
    if (skill.metadata && Object.keys(skill.metadata).length > 0) {
      warnings.push('Custom metadata fields not supported by GitHub Copilot');
    }

    // Add title if content doesn't start with one
    if (!skill.content.trim().startsWith('#')) {
      lines.push(`# ${skill.name.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')}`);
      lines.push('');
      if (skill.description) {
        lines.push(skill.description);
        lines.push('');
      }
    }

    // Add main content
    lines.push(skill.content);

    return {
      success: true,
      content: lines.join('\n'),
      filename: this.getFilename(skill.name, targetAgent),
      warnings,
      incompatible,
      targetFormat: 'markdown-rules',
      targetAgent,
    };
  }

  /**
   * Get the expected filename for GitHub Copilot format
   */
  getFilename(_skillName: string, _targetAgent: AgentType): string {
    return 'copilot-instructions.md';
  }

  /**
   * Get the expected path for the instructions file
   */
  getPath(_skillName: string): string {
    return '.github/copilot-instructions.md';
  }
}

/**
 * Singleton instance
 */
export const copilotTranslator = new CopilotTranslator();
